{"version":3,"sources":["webpack:///./docs/faq.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"oRAQaA,EAAe,Q,mNAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,iBACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,kBACE,GAAM,8BADR,8BAGA,kBACE,GAAM,mBADR,oBAGA,6FACA,gRAIA,oCAAmB,kBAAIC,WAAW,KAAf,aAAnB,QAAiE,kBAAIA,WAAW,KAAf,WAAjE,oEAEA,uEAAsD,iBAAGA,WAAW,IAChE,KAAQ,wBAD0C,yBAGtD,kBACE,GAAM,sCADR,uCAGA,2GACC,0BAAYA,WAAW,KAAvB,WADD,KAC0D,0BAAYA,WAAW,KAAvB,QAD1D,KACgH,0BAAYA,WAAW,KAAvB,QADhH,KACsK,0BAAYA,WAAW,KAAvB,SADtK,MAEA,6IAEA,iCAAgB,0BAAYA,WAAW,KAAvB,WAAhB,iXAIwE,sBAAQA,WAAW,KAAnB,kBAJxE,yCAMA,kBACE,GAAM,uBADR,wBAGA,iHACiB,0BAAYA,WAAW,KAAvB,WADjB,wFAE6B,0BAAYA,WAAW,KAAvB,WAF7B,mBAEoG,0BAAYA,WAAW,KAAvB,WAFpG,oCAGe,iBAAGA,WAAW,IACzB,KAAQ,iEADG,aAHf,gFAOA,kBACE,GAAM,gBADR,iBAGA,+CAA8B,kBAAIA,WAAW,KAAf,qBAA9B,IAAgF,0BAAYA,WAAW,KAAvB,SAAhF,4FAC0D,0BAAYA,WAAW,KAAvB,QAD1D,uGAIA,qEAAoD,0BAAYA,WAAW,KAAvB,QAApD,qMAIA,2K,iNAMJJ,EAAWK,gBAAiB","file":"component---docs-faq-md-6e6eacd83e9da18ef082.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/tanka/tanka/docs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"frequently-asked-questions\"\n    }}>{`Frequently asked questions`}</h1>\n    <h2 {...{\n      \"id\": \"what-is-jsonnet\"\n    }}>{`What is Jsonnet?`}</h2>\n    <p>{`Jsonnet is a data templating language, originally created by Google.`}</p>\n    <p>{`It is a superset of JSON, which adds common structures from full programming\nlanguages to data modeling. Because it being a superset of JSON and ultimately\nalways compiling to JSON, it is guaranteed that the output will be valid JSON\n(or YAML).`}</p>\n    <p>{`By allowing `}<em parentName=\"p\">{`functions`}</em>{` and `}<em parentName=\"p\">{`imports`}</em>{`, rich abstraction is possible, even across\nproject boundaries.`}</p>\n    <p>{`For more, refer to the official documentation: `}<a parentName=\"p\" {...{\n        \"href\": \"https://jsonnet.org/\"\n      }}>{`https://jsonnet.org/`}</a></p>\n    <h2 {...{\n      \"id\": \"how-is-this-different-from-ksonnet\"\n    }}>{`How is this different from ksonnet?`}</h2>\n    <p>{`Tanka aims to be a fully compatible, drop-in replacement for the main workflow\nof `}<inlineCode parentName=\"p\">{`ksonnet`}</inlineCode>{` (`}<inlineCode parentName=\"p\">{`show`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`diff`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`apply`}</inlineCode>{`).`}</p>\n    <p>{`In general, both tools are very similar when it comes to how they handle Jsonnet\nand apply to a Kubernetes cluster.`}</p>\n    <p>{`However, `}<inlineCode parentName=\"p\">{`ksonnet`}</inlineCode>{` included a rich code generator for establishing a CLI based\nworkflow for editing Kubernetes objects. It also used to manage dependencies\nitself and had a lot of concepts for different levels of abstractions. When\ndesigning Tanka, we felt these add more complexity for the user than they\nprovide additional value. To keep Tanka as minimal as possible, these are `}<strong parentName=\"p\">{`not\navailable`}</strong>{` and are not likely to be ever added.`}</p>\n    <h2 {...{\n      \"id\": \"what-about-kubecfg-\"\n    }}>{`What about kubecfg ?`}</h2>\n    <p>{`Tanka development has started at the time when kubecfg was a part of\nalready-deprecated `}<inlineCode parentName=\"p\">{`ksonnet`}</inlineCode>{` project. Although these projects are similar, Tanka\naims to provide continuity for `}<inlineCode parentName=\"p\">{`ksonnet`}</inlineCode>{` users, whereas `}<inlineCode parentName=\"p\">{`kubecfg`}</inlineCode>{` is (according\nto the project's `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/vmware-archive/kubecfg/blob/main/README.md\"\n      }}>{`README.md`}</a>{`)\nreally just a thin Kubernetes-specific wrapper around jsonnet evaluation.`}</p>\n    <h2 {...{\n      \"id\": \"why-not-helm\"\n    }}>{`Why not Helm?`}</h2>\n    <p>{`Helm relies heavily on `}<em parentName=\"p\">{`string templating`}</em>{` `}<inlineCode parentName=\"p\">{`.yaml`}</inlineCode>{` files. We feel this is the\nwrong way to approach the absence of abstractions inside of `}<inlineCode parentName=\"p\">{`yaml`}</inlineCode>{`, because the\ntemplating part of the application has no idea of the structure and syntax of\nyaml.`}</p>\n    <p>{`This makes debugging very hard. Furthermore, `}<inlineCode parentName=\"p\">{`helm`}</inlineCode>{` is not able to provide an\nadequate solution for edge cases. If I wanted to set some parameters that are\nnot already implemented by the Chart, I have no choice but to modify the Chart\nfirst.`}</p>\n    <p>{`Jsonnet on the other hand got you covered by supporting mixing (patching,\ndeep-merging) objects on top of the libraries output if required.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}